serviceAccount:
  create: false

service:
  # Type of Kubernetes service (ClusterIP, NodePort, LoadBalancer)
  type: ClusterIP
  # Port on which Valkey will be exposed
  port: 6379
  annotations: {}
  # NodePort value (if service.type is NodePort)
  nodePort: 0
  # ClusterIP value
  clusterIP: ""
  # Class of a load balancer implementation
  loadBalancerClass: ""
  # If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer
  # will be restricted to the specified client IPs.
  # This field will be ignored if the cloud-provider does not support the feature.
  loadBalancerSourceRanges: []
  # Application protocol
  appProtocol: ""

# Network policy to control traffic to the pods
# More info: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy: {}

# Resource limits/requests for the main Valkey container
resources: {}
  # Example:
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# Persistent storage configuration (standalone deployment only)
dataStorage:
  # Enable persistent volume claim creation
  enabled: false

  # Use existing PVC by name (skip dynamic provisioning if set)
  persistentVolumeClaimName: ""

  # Subpath inside PVC to mount
  subPath: ""

  # Name of the volume (referenced in deployment)
  volumeName: "valkey-data"

  # Request size (e.g. 5Gi) for dynamically provisioned volume
  requestedSize: ""

  # Name of the storage class to use
  className: ""

  # Access modes for the PVC (e.g., ReadWriteOnce, ReadWriteMany)
  accessModes:
    - ReadWriteOnce

  # If true, keep the PVC on Helm uninstall
  keepPvc: false

  # Optional annotations to add to the PVC
  annotations: {}

  # Optional labels to add to the PVC
  labels: {}

  # If hostPath is set then a hostPath DirectoryOrCreate volume is used
  hostPath: ""

# Mount additional secrets into the Valkey container
extraValkeySecrets: []

# Mount additional configMaps into the Valkey container
extraValkeyConfigs: []

# Mount extra secrets as volume to init container (deprecated, use extraValkeySecrets)
extraSecretValkeyConfigs: false

# Mount additional emptyDir or hostPath volumes (advanced use)
extraVolumes: []
#  - name: hostpath-volume
#    hostPath:
#      path: /opt/valkey/hostpath-volume/
#      type: DirectoryOrCreate
extraVolumeMounts: []
#  - mountPath: /some/path/
#    name: hostpath-volume

# Content for valkey.conf (will be mounted via ConfigMap)
valkeyConfig: ""

auth:
  # Enable ACL-based authentication
  # IMPORTANT: When authentication is enabled, the 'default' user MUST be defined in either
  # aclUsers or aclConfig. Without a default user, anyone can access the database without
  # credentials, creating a security risk.
  enabled: false

  # Use an existing secret for user passwords. Key defaults to username.
  usersExistingSecret: ""

  # Map of users to create with ACL permissions.
  # If usersExistingSecret is set, passwords from the secret take priority over inline passwords.
  # NOTE: If using aclUsers, the 'default' user must be included here.
  aclUsers: {}
  # Example:
  # default:
  #   permissions: "~* &* +@all"
  #   password: "secretpass"        # Inline password (fallback if usersExistingSecret not set)
  #   passwordKey: "admin-pwd"      # Key in usersExistingSecret (defaults to username)
  # read-user:
  #   permissions: "~* -@all +@read +ping +info"

  # Inline ACL configuration that will be appended after generated users.
  # NOTE: If using aclConfig, ensure the 'default' user is defined here.
  aclConfig: ""
  # Example:
  # aclConfig: |
  #   user default on >secretpass ~* &* +@all

# Replica configuration for master-replica replication mode
replica:
  enabled: false
  replicas: 2

  # Username for replicas to authenticate to master, ignored if auth.enabled is false.
  # IMPORTANT: When auth.enabled is true, this user MUST be defined in auth.aclUsers.
  # The chart requires this to retrieve the password for replica authentication.
  # The user must have appropriate replication permissions: +psync +replconf +ping
  replicationUser: "default"

  # Replication settings
  # Use diskless replication (sync directly from memory) vs disk-based
  disklessSync: true

  # Write safety - require minimum number of healthy replicas to accept writes
  # Set to 0 to disable this check, or 1+ to require minimum replicas before accepting writes
  # This ensures data durability by requiring at least N replicas to be in sync
  minReplicasToWrite: 0

  # Maximum replication lag in seconds before a replica is considered unhealthy
  minReplicasMaxLag: 10

  # Persistence configuration (required for replicas)
  persistence:
    # Size of the PVC for each replica (required when replica.enabled is true)
    size: ""
    # Storage class name (empty = use default storage class)
    storageClass: ceph-filesystem
    # Access modes for the PVC
    accessModes:
      - ReadWriteOnce

  # PersistentVolumeClaim retention policy for StatefulSet
  # Controls when PVCs are deleted (requires Kubernetes 1.23+)
  # More info: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#persistentvolumeclaim-retention
  persistentVolumeClaimRetentionPolicy: {}

tls:
  # Enable TLS
  enabled: false
  # Name of the Secret containing TLS keys (required)
  existingSecret: ""
  # Secret key name containing server public certificate
  serverPublicKey: server.crt
  # Secret key name containing server private key
  serverKey: server.key
  # Secret key name containing Certificate Authority public certificate
  caPublicKey: ca.crt
  # Secret key name containing DH parameters (optional)
  dhParamKey: ""
  # Require that clients authenticate with a certificate
  requireClientCertificate: false

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - topologyKey: kubernetes.io/hostname

# Valkey logging level: debug, verbose, notice, warning
valkeyLogLevel: "notice"
# Environment variables to inject into Valkey container

env: {}
  # Example:
  # LOG_LEVEL: info

metrics:
  enabled: true

  prometheusRule:
    enabled: false
    # List of Prometheus alerting rules
    rules: []
    # Example alerting rules:
    # - alert: ValkeyDown
    #   annotations:
    #     summary: Valkey instance {{ "{{ $labels.instance }}" }} down
    #     description: Valkey instance {{ "{{ $labels.instance }}" }} is down.
    #   expr: |
    #     redis_up{service="{{ include "valkey.fullname" . }}-metrics"} == 0
    #   for: 2m
    #   labels:
    #     severity: error
    # - alert: ValkeyMemoryHigh
    #   annotations:
    #     summary: Valkey instance {{ "{{ $labels.instance }}" }} is using too much memory
    #     description: |
    #        Valkey instance {{ "{{ $labels.instance }}" }} is using {{ "{{ $value }}" }}% of its available memory.
    #   expr: |
    #      redis_memory_used_bytes{service="{{ include "valkey.fullname" . }}-metrics"} * 100
    #      /
    #      redis_memory_max_bytes{service="{{ include "valkey.fullname" . }}-metrics"}
    #      > 90 <= 100
    #   for: 2m
    #   labels:
    #     severity: error
    # - alert: ValkeyKeyEviction
    #   annotations:
    #     summary: Valkey instance {{ "{{ $labels.instance }}" }} has evicted keys
    #     description: |
    #        Valkey instance {{ "{{ $labels.instance }}" }} has evicted {{ "{{ $value }}" }} keys in the last 5 minutes.
    #   expr: |
    #     increase(redis_evicted_keys_total{service="{{ include "valkey.fullname" . }}-metrics"}[5m]) > 0
    #   for: 1s
    #   labels:
    #     severity: error

  service:
    enabled: true

  serviceMonitor:
    enabled: true
